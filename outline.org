* Intro

  - Going to be talking about memory models, in particular those
    related to C and LLVM.

  - These languages have some interesting trade-offs that we are going
    to discuss.

* A diversion into undefined behaviour

  - Might seem like a really bad idea at first -- why not specify how your
    programming language behaves in every situation?

  - Actually a tool to give compilers a more powerful foundation to work with.
    + Compilers can now assume that your programs *don't* do things, like aliasing
    + Hard for a compiler to prove about programs automatically
      * Also hard for people to prove manually, but... That's another
        issue.

  - Different from implementation-defined / unspecified behaviour:
    + Programs exhibiting undefined behaviour are *not* valid programs.

* Why Undefined Behaviours?

  Undefined behaviours can specify some intent to the compiler. If you write this program:

  #+begin_src c
    int ub_test(int x)
    {
        int v = 100000;
        v += x;

        if (v < 100000) {
            foo();
        }

        return v;
    }
  #+end_src


  In C signed integer overflow is considered undefined behaviour, so compilers are allowed to optimize the above to this:

  #+begin_src c
    int ub_test(int x)
    {
        int v = 100000;
        v += x;
        return v;
    }
  #+end_src


  - /Morally/ this is what you want.
  - Over-specifying that ~v~ has to wrap-around makes optimizations
    much more difficult to justify. Might not match up with behaviour
    of underlying architecture either (e.g., might store 32-bit int in
    a 64-bit register for convenience).

* Differences of Opinion

  You might want your compiler to optimize the first to the second, as
  this may well be the programmer's intent

    #+begin_src c
      void multiply(size_t length, int *a, int *b, int *out)
      {
          for (size_t i = 0; i < length; ++i) {
              out[i] = (*a) * b[i];
          }
      }

      void multiply_fast(size_t length, int *a, int *b, int *out)
      {
          int a0 = *a;
          for (size_t i = 0; i < length; ++i) {
              out[i] = a0 * b[i];
          }
      }
    #+end_src

    But C compilers can't actually make this optimization!

    - ~a~ and some ~&out[i]~ could alias!
    - have to load from ~a~ each time, even though all usages of this
      function might not have aliasing :(.

    In contrast, Fortran assumes these arguments don't alias, and thus
    Fortran compilers *can* make this optimization.

* Tradeoffs

  Some great benefits to UB:

  - Compiler can trigger more optimizations.
  - Gives the compiler greater reasoning abilities.
  - Having more UB can give even more opportunities.

  Obvious tradeoffs to undefined behaviour:

  - Something programmers have to keep in mind
    + Especially since these are things that are hard for tools to
      detect automatically.
    + This is part of why it's useful. Gives another axiom for
      analysis, but programmer must ensure these assumptions hold.
  - Can lead to very unexpected behaviour if triggered.

* TODO Other Weird Things about UB

  - If the compiler can prove that a branch exhibits UB, it can remove
    that entire branch.
  - This is somewhat different than just assuming the behaviour can't
    happen. It's actively seeking out places where UB could be
    triggered and then assuming that these places can't be reached
    because of it.

* TODO What is a memory model

  - Model's the behaviour of memory for the computer
  - Programmers and compilers need to understand how memory works in
    order to write correct programs and perform optimizations safely
    + EXAMPLE OF SOME BEHAVIOURS YOU MIGHT WANT TO KNOW ABOUT

* Concrete vs Abstract

  - Concrete:
    + Model memory as a giant array
    + finite (partial) map from addresses to /bytes/
  - Abstract:
    + Maybe have hard distinctions between pointers and integers
    + Don't allow probing bitwise representations of values

* C Programming Language

  - What makes it a "systems programming language?"
  - You can manipulate memory "directly".
    + Pointer <-> integer casts :O

* TODO Ambiguity in C

  - The specification is intentionally loose about how memory behaves.
  - Specifying memory operations precisely can make the language inefficient on different platforms
    + EXAMPLE. Stack growing in a certain direction?

* Crazy GCC Examples

  - ... and why they're "valid".

* What does the C memory model look like?

* WAT

* The Standards are not Perfect

  Nor are they set in stone.

  The discussion coming up involves a somewhat disputed part of the C
  standard, which people are working to possibly change. As such two
  models of handling pointers and integers are presented, each with
  different advantages and disadvantages.

* Provenance

  - Tracking "ownership". Where things come from.
  - In the context of pointers, each allocation generates a new provenance.

* TODO PVI

  WG14

   #+begin_example
     Implementations are permitted to track the origins of a bit-pattern
     and [...]. They may also treat pointers based on different origins as
     distinct even though they are bitwise identical.‚Äù
   #+end_example

* PNVI

  Integers don't 

* Summary: Pros and Cons of PVI / PNVI
